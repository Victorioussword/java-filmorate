package ru.yandex.practicum.filmorate.storage;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.jdbc.support.rowset.SqlRowSet;
import org.springframework.stereotype.Component;
import ru.yandex.practicum.filmorate.model.User;

import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;


@Slf4j
@RequiredArgsConstructor
@Component("usersInDB")
@Primary
public class UserDbStorage implements UserStorage {

    private final JdbcTemplate jdbcTemplate = new JdbcTemplate();

    @Override
    public Optional<User> getById(long id) {

        final String sqlQuery = "SELECT *"
                + " FROM USERS" +
                "WHERE USER_ID = ?";

        SqlRowSet userRows = jdbcTemplate.queryForRowSet(sqlQuery, id);
        if (userRows.next()) {
            User user = makeUser(userRows);
            log.info("Найден пользователь: {} {}", user.getId(), user.getName());
            return Optional.of(user);

        } else {
            log.info("Пользователь с идентификатором {} не найден.", id);
            return Optional.empty();
        }
    }

    @Override
    public Map<Long, User> getAll() {
        final String sqlQuery = "SELECT *"
                + " FROM USERS";

        List<User> users = jdbcTemplate.queryForList(sqlQuery, User.class);
        Map<Long, User> usersForReturn = new HashMap<>();

        for (int i = 0; i < users.size(); i++) {
            usersForReturn.put(users.get(i).getId(), users.get(i));
        }
        return usersForReturn;
    }

    @Override
    public Optional<User> add(User user) {
        final String sqlQuery = "INSERT INTO USERS (USER_EMAIL, USER_LOGIN, USER_NAME, BIRTHDAY) " +
                "VALUES ( ?, ?, ?, ?)";
        KeyHolder generatedId = new GeneratedKeyHolder();

        jdbcTemplate.update(connection -> {
            final PreparedStatement preparedStatement = connection.prepareStatement(sqlQuery, new String[]{"USER_ID"});
            preparedStatement.setString(1, user.getEmail());
            preparedStatement.setString(2, user.getLogin());
            preparedStatement.setString(3, user.getName());
            preparedStatement.setDate(4, Date.valueOf(user.getBirthday()));
            return preparedStatement;
        }, generatedId);

        log.info("Пользователь с id {} отправлен", user.getId());
        user.setId(generatedId.getKey().intValue());


        return Optional.of(user);
    }
/*
* USER_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                       USER_EMAIL varchar (50) NOT null,
                       BIRTHDAY date NOT null,
                       USER_LOGIN varchar (50) NOT null,
                       USER_NAME varchar (50)
*
*
* */



    @Override
    public User update(User user) {
        long id = user.getId();
        String name = user.getName();
        String login = user.getLogin();
        String email = user.getEmail();
        String birthday = user.getBirthday().toString();

        final String sqlQuery = "UPDATE USERS" +
                "SET USER_NAME = " + name +
                ", USER_LOGIN=" + login +
                ", USER_EMAIL = " + email +
                ", BIRTHDAY = " + birthday +
                "WHERE USER_ID = " + id;
        SqlRowSet userRows = jdbcTemplate.queryForRowSet(sqlQuery);
        User userForReturn = makeUser(userRows);
        return userForReturn;
    }

    public void addFriend(long userId, long friendId) {   // проверка наличия ключа не требуется - настроена связь между таблицами
        // необходима проверка дублирования дружбы

        String sqlQuery = "INSERT INTO FRIENDSHIP (USER_ID,  FRIEND_ID) " +
                "VALUES (userId, FRIEND_ID)";
        jdbcTemplate.queryForRowSet(sqlQuery);
    }

    @Override
    public User delFriendship(long userId, long friendId) {
        final String sqlQuery = " DELETE FROM FRIENDSHIP" +
                " WHERE (USER_ID  = userId AND FRIEND_ID = friendId) OR (USER_ID = friendId AND FRIEND_ID = userId)";

        return null;
    }


    public List<User> getFriends(long id) {
        final String sqlQuery = "SELECT *"
                + " FROM USERS" +
                "WHERE FRIENDSHIP.USER_ID =" + id;
        List<User> users = jdbcTemplate.queryForList(sqlQuery, User.class);

        return users;
    }


  private User makeUser(SqlRowSet userRows) {
        User user = new User(
                Long.parseLong(userRows.getString("USER_ID")),
                userRows.getString("USER_EMAIL"),
                userRows.getString("USER_LOGIN"),
                userRows.getString("USER_NAME"),
                LocalDate.parse(userRows.getString("BIRTHDAY")));



        return user;
    }



/**
    private User makeUser(ResultSet resultSet, int rowNum) throws SQLException {
        int id = resultSet.getInt("id");
        String email = resultSet.getString("email");
        String login = resultSet.getString("login");
        String name = resultSet.getString("name");
        LocalDate birthday = resultSet.getDate("birthday").toLocalDate();

        return new User(id, email, login, name, birthday);
    }
   */



}
